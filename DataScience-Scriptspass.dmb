unary-operations
	fneg-instruction
		Syntax:
			<result> = fneg [fast-math flags]* <ty> <op1>   ; yields ty:result
		Arguments:
			The argument to the ‘fneg’ instruction must be a floating-point or vector of floating-point values.
		Overview:
			The ‘fneg’ instruction returns the negation of its operand.
		Example:
			<result> = fneg float %val          ; yields float:result = -%var
binary-operations
	add-instruction
		Syntax:
			<result> = add <ty> <op1>, <op2>          ; yields ty:result
			<result> = add nuw <ty> <op1>, <op2>      ; yields ty:result
			<result> = add nsw <ty> <op1>, <op2>      ; yields ty:result
			<result> = add nuw nsw <ty> <op1>, <op2>  ; yields ty:result
		Arguments:
			The two arguments to the ‘add’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘add’ instruction returns the sum of its two operands.
		Example:
			<result> = add i32 4, %var          ; yields i32:result = 4 + %var
	fadd-instruction
		Syntax:
			<result> = fadd [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘fadd’ instruction must be floating-point or vector of floating-point values. Both arguments must have identical types.
		Overview:
			The ‘fadd’ instruction returns the sum of its two operands.
		Example:
			<result> = fadd float 4.0, %var          ; yields float:result = 4.0 + %var
	sub-instruction
		Syntax:
			<result> = sub <ty> <op1>, <op2>          ; yields ty:result
			<result> = sub nuw <ty> <op1>, <op2>      ; yields ty:result
			<result> = sub nsw <ty> <op1>, <op2>      ; yields ty:result
			<result> = sub nuw nsw <ty> <op1>, <op2>  ; yields ty:result
		Arguments:
			The two arguments to the ‘sub’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘sub’ instruction returns the difference of its two operands.
			Note that the ‘sub’ instruction is used to represent the ‘neg’ instruction present in most other intermediate representations.
		Example:
			<result> = sub i32 4, %var          ; yields i32:result = 4 - %var
			<result> = sub i32 0, %val          ; yields i32:result = -%var
	fsub-instruction
		Syntax:
			<result> = fsub [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘fsub’ instruction must be floating-point or vector of floating-point values. Both arguments must have identical types.
		Overview:
			The ‘fsub’ instruction returns the difference of its two operands.
		Example:
			<result> = fsub float 4.0, %var           ; yields float:result = 4.0 - %var
			<result> = fsub float -0.0, %val          ; yields float:result = -%var
	mul-instruction
		Syntax:
			<result> = mul <ty> <op1>, <op2>          ; yields ty:result
			<result> = mul nuw <ty> <op1>, <op2>      ; yields ty:result
			<result> = mul nsw <ty> <op1>, <op2>      ; yields ty:result
			<result> = mul nuw nsw <ty> <op1>, <op2>  ; yields ty:result
		Arguments:
			The two arguments to the ‘mul’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘mul’ instruction returns the product of its two operands.
		Example:
			<result> = mul i32 4, %var          ; yields i32:result = 4 * %var
	fmul-instruction
		Syntax:
			<result> = fmul [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘fmul’ instruction must be floating-point or vector of floating-point values. Both arguments must have identical types.
		Overview:
			The ‘fmul’ instruction returns the product of its two operands.
		Example:
			<result> = fmul float 4.0, %var          ; yields float:result = 4.0 * %var
	udiv-instruction
		Syntax:
			<result> = udiv <ty> <op1>, <op2>         ; yields ty:result
			<result> = udiv exact <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘udiv’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘udiv’ instruction returns the quotient of its two operands.
		Example:
			<result> = udiv i32 4, %var          ; yields i32:result = 4 / %var
	sdiv-instruction
		Syntax:
			<result> = sdiv <ty> <op1>, <op2>         ; yields ty:result
			<result> = sdiv exact <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘sdiv’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘sdiv’ instruction returns the quotient of its two operands.
		Example:
			<result> = sdiv i32 4, %var          ; yields i32:result = 4 / %var
	fdiv-instruction
		Syntax:
			<result> = fdiv [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘fdiv’ instruction must be floating-point or vector of floating-point values. Both arguments must have identical types.
		Overview:
			The ‘fdiv’ instruction returns the quotient of its two operands.
		Example:
			<result> = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var
	urem-instruction
		Syntax:
			<result> = urem <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘urem’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘urem’ instruction returns the remainder from the unsigned division of its two arguments.
		Example:
			<result> = urem i32 4, %var          ; yields i32:result = 4 % %var
	srem-instruction
		Syntax:
			<result> = srem <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘srem’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘srem’ instruction returns the remainder from the signed division of its two operands. This instruction can also take vector versions of the values in which case the elements must be integers.
		Example:
			<result> = srem i32 4, %var          ; yields i32:result = 4 % %var
	frem-instruction
		Syntax:
			<result> = frem [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘frem’ instruction must be floating-point or vector of floating-point values. Both arguments must have identical types.
		Overview:
			The ‘frem’ instruction returns the remainder from the division of its two operands.
		Example:
			<result> = frem float 4.0, %var          ; yields float:result = 4.0 % %var
bitwise-binary-operations
	shl-instruction
		Syntax:
			<result> = shl <ty> <op1>, <op2>           ; yields ty:result
			<result> = shl nuw <ty> <op1>, <op2>       ; yields ty:result
			<result> = shl nsw <ty> <op1>, <op2>       ; yields ty:result
			<result> = shl nuw nsw <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			Both arguments to the ‘shl’ instruction must be the same integer or vector of integer type. ‘op2’ is treated as an unsigned value.
		Overview:
			The ‘shl’ instruction returns the first operand shifted to the left a specified number of bits.
		Example:
			<result> = shl i32 4, %var   ; yields i32: 4 << %var
			<result> = shl i32 4, 2      ; yields i32: 16
			<result> = shl i32 1, 10     ; yields i32: 1024
			<result> = shl i32 1, 32     ; undefined
			<result> = shl <2 x i32> < i32 1, i32 1>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 2, i32 4>
	lshr-instruction
		Syntax:
			<result> = lshr <ty> <op1>, <op2>         ; yields ty:result
			<result> = lshr exact <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			Both arguments to the ‘lshr’ instruction must be the same integer or vector of integer type. ‘op2’ is treated as an unsigned value.
		Overview:
			The ‘lshr’ instruction (logical shift right) returns the first operand shifted to the right a specified number of bits with zero fill.
		Example:
			<result> = lshr i32 4, 1   ; yields i32:result = 2
			<result> = lshr i32 4, 2   ; yields i32:result = 1
			<result> = lshr i8  4, 3   ; yields i8:result = 0
			<result> = lshr i8 -2, 1   ; yields i8:result = 0x7F
			<result> = lshr i32 1, 32  ; undefined
			<result> = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>
	ashr-instruction
		Syntax:
			<result> = ashr <ty> <op1>, <op2>         ; yields ty:result
			<result> = ashr exact <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			Both arguments to the ‘ashr’ instruction must be the same integer or vector of integer type. ‘op2’ is treated as an unsigned value.
		Overview:
			The ‘ashr’ instruction (arithmetic shift right) returns the first operand shifted to the right a specified number of bits with sign extension.
		Example:
			<result> = ashr i32 4, 1   ; yields i32:result = 2
			<result> = ashr i32 4, 2   ; yields i32:result = 1
			<result> = ashr i8  4, 3   ; yields i8:result = 0
			<result> = ashr i8 -2, 1   ; yields i8:result = -1
			<result> = ashr i32 1, 32  ; undefined
			<result> = ashr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 3>   ; yields: result=<2 x i32> < i32 -1, i32 0>
	and-instruction
		Syntax:
			<result> = and <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘and’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘and’ instruction returns the bitwise logical and of its two operands.
		Example:
			<result> = and i32 4, %var         ; yields i32:result = 4 & %var
			<result> = and i32 15, 40          ; yields i32:result = 8
			<result> = and i32 4, 8            ; yields i32:result = 0
	or-instruction
		Syntax:
			<result> = or <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘or’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘or’ instruction returns the bitwise logical inclusive or of its two operands.
		Example:
			<result> = or i32 4, %var         ; yields i32:result = 4 | %var
			<result> = or i32 15, 40          ; yields i32:result = 47
			<result> = or i32 4, 8            ; yields i32:result = 12
	xor-instruction
		Syntax:
			<result> = xor <ty> <op1>, <op2>   ; yields ty:result
		Arguments:
			The two arguments to the ‘xor’ instruction must be integer or vector of integer values. Both arguments must have identical types.
		Overview:
			The ‘xor’ instruction returns the bitwise logical exclusive or of its two operands. The xor is used to implement the “one’s complement” operation, which is the “~” operator in C.
		Example:
			<result> = xor i32 4, %var         ; yields i32:result = 4 ^ %var
			<result> = xor i32 15, 40          ; yields i32:result = 39
			<result> = xor i32 4, 8            ; yields i32:result = 12
			<result> = xor i32 %V, -1          ; yields i32:result = ~%V
vector-operations
	extractelement-instruction
		Syntax:
			<result> = extractelement <n x <ty>> <val>, <ty2> <idx>  ; yields <ty>
			<result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>
		Arguments:
			The first operand of an ‘extractelement’ instruction is a value of vector type. The second operand is an index indicating the position from which to extract the element. The index may be a variable of any integer type.
		Overview:
			The ‘extractelement’ instruction extracts a single scalar element from a vector at a specified index.
		Example:
			<result> = extractelement <4 x i32> %vec, i32 0    ; yields i32
	insertelement-instruction
		Syntax:
			<result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx>    ; yields <n x <ty>>
			<result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>
		Arguments:
			The first operand of an ‘insertelement’ instruction is a value of vector type. The second operand is a scalar value whose type must equal the element type of the first operand. The third operand is an index indicating the position at which to insert the value. The index may be a variable of any integer type.
		Overview:
			The ‘insertelement’ instruction inserts a scalar element into a vector at a specified index.
		Example:
			<result> = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>
	shufflevector-instruction
		Syntax:
			<result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask>    ; yields <m x <ty>>
			<result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask>  ; yields <vscale x m x <ty>>
		Arguments:
			The first two operands of a ‘shufflevector’ instruction are vectors with the same type. The third argument is a shuffle mask vector constant whose element type is i32. The mask vector elements must be constant integers or undef values. The result of the instruction is a vector whose length is the same as the shuffle mask and whose element type is the same as the element type of the first two operands.
		Overview:
			The ‘shufflevector’ instruction constructs a permutation of elements from two input vectors, returning a vector with the same element type as the input and length that is the same as the shuffle mask.
		Example:
			<result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,
			                        <4 x i32> <i32 0, i32 4, i32 1, i32 5>  ; yields <4 x i32>
			<result> = shufflevector <4 x i32> %v1, <4 x i32> undef,
			                        <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32> - Identity shuffle.
			<result> = shufflevector <8 x i32> %v1, <8 x i32> undef,
			                        <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32>
			<result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,
			                        <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >  ; yields <8 x i32>
aggregate-operations
	extractvalue-instruction
		Syntax:
			<result> = extractvalue <aggregate type> <val>, <idx>{, <idx>}*
		Arguments:
			The first operand of an ‘extractvalue’ instruction is a value of struct or array type. The other operands are constant indices to specify which value to extract in a similar manner as indices in a ‘getelementptr’ instruction.
			The major differences to getelementptr indexing are:
			Since the value being indexed is not a pointer, the first index is omitted and assumed to be zero.
			At least one index must be specified.
			Not only struct indices but also array indices must be in bounds.
		Overview:
			The ‘extractvalue’ instruction extracts the value of a member field from an aggregate value.
		Example:
			<result> = extractvalue {i32, float} %agg, 0    ; yields i32
	insertvalue-instruction
		Syntax:
			<result> = insertvalue <aggregate type> <val>, <ty> <elt>, <idx>{, <idx>}*    ; yields <aggregate type>
		Arguments:
			The first operand of an ‘insertvalue’ instruction is a value of struct or array type. The second operand is a first-class value to insert. The following operands are constant indices indicating the position at which to insert the value in a similar manner as indices in a ‘extractvalue’ instruction. The value to insert must have the same type as the value identified by the indices.
		Overview:
			The ‘insertvalue’ instruction inserts a value into a member field in an aggregate value.
		Example:
			%agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}
			%agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}
			%agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0    ; yields {i32 undef, {float %val}}
memory-access-and-addressing-operations
	alloca-instruction
		Syntax:
			<result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)]     ; yields type addrspace(num)*:result
		Arguments:
			The ‘alloca’ instruction allocates sizeof(<type>)*NumElements bytes of memory on the runtime stack, returning a pointer of the appropriate type to the program. If “NumElements” is specified, it is the number of elements allocated, otherwise “NumElements” is defaulted to be one. If a constant alignment is specified, the value result of the allocation is guaranteed to be aligned to at least that boundary. The alignment may not be greater than 1 << 29. If not specified, or if zero, the target can choose to align the allocation on any convenient boundary compatible with the type.
			‘type’ may be any sized type.
		Overview:
			The ‘alloca’ instruction allocates memory on the stack frame of the currently executing function, to be automatically released when this function returns to its caller. The object is always allocated in the address space for allocas indicated in the datalayout.
		Example:
			%ptr = alloca i32                             ; yields i32*:ptr
			%ptr = alloca i32, i32 4                      ; yields i32*:ptr
			%ptr = alloca i32, i32 4, align 1024          ; yields i32*:ptr
			%ptr = alloca i32, align 1024                 ; yields i32*:ptr
	load-instruction
		Syntax:
			<result> = load [volatile] <ty>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>][, !invariant.load !<index>][, !invariant.group !<index>][, !nonnull !<index>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>]
			<result> = load atomic [volatile] <ty>, <ty>* <pointer> [syncscope("<target-scope>")] <ordering>, align <alignment> [, !invariant.group !<index>]
			!<index> = !{ i32 1 }
			!<deref_bytes_node> = !{i64 <dereferenceable_bytes>}
			!<align_node> = !{ i64 <value_alignment> }
		Arguments:
			The argument to the load instruction specifies the memory address from which to load. The type specified must be a first class type of known size (i.e. not containing an opaque structural type). If the load is marked as volatile, then the optimizer is not allowed to modify the number or order of execution of this load with other volatile operations.
			If the load is marked as atomic, it takes an extra ordering and optional syncscope("<target-scope>") argument. The release and acq_rel orderings are not valid on load instructions. Atomic loads produce defined results when they may see multiple atomic stores. The type of the pointee must be an integer, pointer, or floating-point type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. align must be explicitly specified on atomic loads, and the load has undefined behavior if the alignment is not set to a value which is at least the size in bytes of the pointee. !nontemporal does not have any defined semantics for atomic loads.
			The optional constant align argument specifies the alignment of the operation (that is, the alignment of the memory address). A value of 0 or an omitted align argument means that the operation has the ABI alignment for the target. It is the responsibility of the code emitter to ensure that the alignment information is correct. Overestimating the alignment results in undefined behavior. Underestimating the alignment may produce less efficient code. An alignment of 1 is always safe. The maximum possible alignment is 1 << 29. An alignment value higher than the size of the loaded type implies memory up to the alignment value bytes can be safely loaded without trapping in the default address space. Access of the high bytes can interfere with debugging tools, so should not be accessed if the function has the sanitize_thread or sanitize_address attributes.
			The optional !nontemporal metadata must reference a single metadata name <index> corresponding to a metadata node with one i32 entry of value 1. The existence of the !nontemporal metadata on the instruction tells the optimizer and code generator that this load is not expected to be reused in the cache. The code generator may select special instructions to save cache bandwidth, such as the MOVNT instruction on x86.
			The optional !invariant.load metadata must reference a single metadata name <index> corresponding to a metadata node with no entries. If a load instruction tagged with the !invariant.load metadata is executed, the optimizer may assume the memory location referenced by the load contains the same value at all points in the program where the memory location is known to be dereferenceable; otherwise, the behavior is undefined.
			The optional !invariant.group metadata must reference a single metadata name
			<index> corresponding to a metadata node with no entries. See invariant.group metadata invariant.group
			The optional !nonnull metadata must reference a single metadata name <index> corresponding to a metadata node with no entries. The existence of the !nonnull metadata on the instruction tells the optimizer that the value loaded is known to never be null. If the value is null at runtime, the behavior is undefined. This is analogous to the nonnull attribute on parameters and return values. This metadata can only be applied to loads of a pointer type.
			The optional !dereferenceable metadata must reference a single metadata name <deref_bytes_node> corresponding to a metadata node with one i64 entry. See dereferenceable metadata dereferenceable
			The optional !dereferenceable_or_null metadata must reference a single metadata name <deref_bytes_node> corresponding to a metadata node with one i64 entry. See dereferenceable_or_null metadata dereferenceable_or_null
			The optional !align metadata must reference a single metadata name <align_node> corresponding to a metadata node with one i64 entry. The existence of the !align metadata on the instruction tells the optimizer that the value loaded is known to be aligned to a boundary specified by the integer value in the metadata node. The alignment must be a power of 2. This is analogous to the ‘’align’’ attribute on parameters and return values. This metadata can only be applied to loads of a pointer type. If the returned value is not appropriately aligned at runtime, the behavior is undefined.
		Overview:
			The ‘load’ instruction is used to read from memory.
		Examples:
			%ptr = alloca i32                               ; yields i32*:ptr
			store i32 3, i32* %ptr                          ; yields void
			%val = load i32, i32* %ptr                      ; yields i32:val = i32 3
	store-instruction
		Syntax:
			store [volatile] <ty> <value>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>][, !invariant.group !<index>]        ; yields void
			store atomic [volatile] <ty> <value>, <ty>* <pointer> [syncscope("<target-scope>")] <ordering>, align <alignment> [, !invariant.group !<index>] ; yields void
		Arguments:
			There are two arguments to the store instruction: a value to store and an address at which to store it. The type of the <pointer> operand must be a pointer to the first class type of the <value> operand. If the store is marked as volatile, then the optimizer is not allowed to modify the number or order of execution of this store with other volatile operations. Only values of first class types of known size (i.e. not containing an opaque structural type) can be stored.
			If the store is marked as atomic, it takes an extra ordering and optional syncscope("<target-scope>") argument. The acquire and acq_rel orderings aren’t valid on store instructions. Atomic loads produce defined results when they may see multiple atomic stores. The type of the pointee must be an integer, pointer, or floating-point type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. align must be explicitly specified on atomic stores, and the store has undefined behavior if the alignment is not set to a value which is at least the size in bytes of the pointee. !nontemporal does not have any defined semantics for atomic stores.
			The optional constant align argument specifies the alignment of the operation (that is, the alignment of the memory address). A value of 0 or an omitted align argument means that the operation has the ABI alignment for the target. It is the responsibility of the code emitter to ensure that the alignment information is correct. Overestimating the alignment results in undefined behavior. Underestimating the alignment may produce less efficient code. An alignment of 1 is always safe. The maximum possible alignment is 1 << 29. An alignment value higher than the size of the stored type implies memory up to the alignment value bytes can be stored to without trapping in the default address space. Storing to the higher bytes however may result in data races if another thread can access the same address. Introducing a data race is not allowed. Storing to the extra bytes is not allowed even in situations where a data race is known to not exist if the function has the sanitize_address attribute.
			The optional !nontemporal metadata must reference a single metadata name <index> corresponding to a metadata node with one i32 entry of value 1. The existence of the !nontemporal metadata on the instruction tells the optimizer and code generator that this load is not expected to be reused in the cache. The code generator may select special instructions to save cache bandwidth, such as the MOVNT instruction on x86.
			The optional !invariant.group metadata must reference a single metadata name <index>. See invariant.group metadata.
		Overview:
			The ‘store’ instruction is used to write to memory.
		Example:
			%ptr = alloca i32                               ; yields i32*:ptr
			store i32 3, i32* %ptr                          ; yields void
			%val = load i32, i32* %ptr                      ; yields i32:val = i32 3
	fence-instruction
		Syntax:
			fence [syncscope("<target-scope>")] <ordering>  ; yields void
		Arguments:
			‘fence’ instructions take an ordering argument which defines what synchronizes-with edges they add. They can only be given acquire, release, acq_rel, and seq_cst orderings.
		Overview:
			The ‘fence’ instruction is used to introduce happens-before edges between operations.
		Example:
			fence acquire                                        ; yields void
			fence syncscope("singlethread") seq_cst              ; yields void
			fence syncscope("agent") seq_cst                     ; yields void
	cmpxchg-instruction
		Syntax:
			cmpxchg [weak] [volatile] <ty>* <pointer>, <ty> <cmp>, <ty> <new> [syncscope("<target-scope>")] <success ordering> <failure ordering> ; yields  { ty, i1 }
		Arguments:
			There are three arguments to the ‘cmpxchg’ instruction: an address to operate on, a value to compare to the value currently be at that address, and a new value to place at that address if the compared values are equal. The type of ‘<cmp>’ must be an integer or pointer type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. ‘<cmp>’ and ‘<new>’ must have the same type, and the type of ‘<pointer>’ must be a pointer to that type. If the cmpxchg is marked as volatile, then the optimizer is not allowed to modify the number or order of execution of this cmpxchg with other volatile operations.
			The success and failure ordering arguments specify how this cmpxchg synchronizes with other atomic operations. Both ordering parameters must be at least monotonic, the ordering constraint on failure must be no stronger than that on success, and the failure ordering cannot be either release or acq_rel.
			A cmpxchg instruction can also take an optional “syncscope” argument.
			The pointer passed into cmpxchg must have alignment greater than or equal to the size in memory of the operand.
		Overview:
			The ‘cmpxchg’ instruction is used to atomically modify memory. It loads a value in memory and compares it to a given value. If they are equal, it tries to store a new value into the memory.
		Example:
			entry:
			  %orig = load atomic i32, i32* %ptr unordered, align 4                      ; yields i32
			  br label %loop
			
			loop:
			  %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]
			  %squared = mul i32 %cmp, %cmp
			  %val_success = cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }
			  %value_loaded = extractvalue { i32, i1 } %val_success, 0
			  %success = extractvalue { i32, i1 } %val_success, 1
			  br i1 %success, label %done, label %loop
			
			done:
			  ...
	atomicrmw-instruction
		Syntax:
			atomicrmw [volatile] <operation> <ty>* <pointer>, <ty> <value> [syncscope("<target-scope>")] <ordering>                   ; yields ty
		Arguments:
			There are three arguments to the ‘atomicrmw’ instruction: an operation to apply, an address whose value to modify, an argument to the operation. The operation must be one of the following keywords:
			xchg
			add
			sub
			and
			nand
			or
			xor
			max
			min
			umax
			umin
			fadd
			fsub
			For most of these operations, the type of ‘<value>’ must be an integer type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. For xchg, this may also be a floating point type with the same size constraints as integers. For fadd/fsub, this must be a floating point type. The type of the ‘<pointer>’ operand must be a pointer to that type. If the atomicrmw is marked as volatile, then the optimizer is not allowed to modify the number or order of execution of this atomicrmw with other volatile operations.
			A atomicrmw instruction can also take an optional “syncscope” argument.
		Overview:
			The ‘atomicrmw’ instruction is used to atomically modify memory.
		Example:
			%old = atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32
	getelementptr-instruction
		Syntax:
			<result> = getelementptr <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
			<result> = getelementptr inbounds <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
			<result> = getelementptr <ty>, <ptr vector> <ptrval>, [inrange] <vector index type> <idx>
		Arguments:
			The first argument is always a type used as the basis for the calculations. The second argument is always a pointer or a vector of pointers, and is the base address to start from. The remaining arguments are indices that indicate which of the elements of the aggregate object are indexed. The interpretation of each index is dependent on the type being indexed into. The first index always indexes the pointer value given as the second argument, the second index indexes a value of the type pointed to (not necessarily the value directly pointed to, since the first index can be non-zero), etc. The first type indexed into must be a pointer value, subsequent types can be arrays, vectors, and structs. Note that subsequent types being indexed into can never be pointers, since that would require loading the pointer before continuing calculation.
			The type of each index argument depends on the type it is indexing into. When indexing into a (optionally packed) structure, only i32 integer constants are allowed (when using a vector of indices they must all be the same i32 integer constant). When indexing into an array, pointer or vector, integers of any width are allowed, and they are not required to be constant. These integers are treated as signed values where relevant.
			For example, let’s consider a C code fragment and how it gets compiled to LLVM:
			struct RT {
			  char A;
			  int B[10][20];
			  char C;
			};
			struct ST {
			  int X;
			  double Y;
			  struct RT Z;
			};
			
			int *foo(struct ST *s) {
			  return &s[1].Z.B[5][13];
			}
			The LLVM code generated by Clang is:
			%struct.RT = type { i8, [10 x [20 x i32]], i8 }
			%struct.ST = type { i32, double, %struct.RT }
			
			define i32* @foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {
			entry:
			  %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13
			  ret i32* %arrayidx
			}
		Overview:
			The ‘getelementptr’ instruction is used to get the address of a subelement of an aggregate data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses.
		Example:
			; yields [12 x i8]*:aptr
			%aptr = getelementptr {i32, [12 x i8]}, {i32, [12 x i8]}* %saptr, i64 0, i32 1
			; yields i8*:vptr
			%vptr = getelementptr {i32, <2 x i8>}, {i32, <2 x i8>}* %svptr, i64 0, i32 1, i32 1
			; yields i8*:eptr
			%eptr = getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1
			; yields i32*:iptr
			%iptr = getelementptr [10 x i32], [10 x i32]* @arr, i16 0, i16 0
conversion-operations
	trunc-to-instruction
		Syntax:
			<result> = trunc <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘trunc’ instruction takes a value to trunc, and a type to trunc it to. Both types must be of integer types, or vectors of the same number of integers. The bit size of the value must be larger than the bit size of the destination type, ty2. Equal sized types are not allowed.
		Overview:
			The ‘trunc’ instruction truncates its operand to the type ty2.
		Example:
			%X = trunc i32 257 to i8                        ; yields i8:1
			%Y = trunc i32 123 to i1                        ; yields i1:true
			%Z = trunc i32 122 to i1                        ; yields i1:false
			%W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>
	zext-to-instruction
		Syntax:
			<result> = zext <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘zext’ instruction takes a value to cast, and a type to cast it to. Both types must be of integer types, or vectors of the same number of integers. The bit size of the value must be smaller than the bit size of the destination type, ty2.
		Overview:
			The ‘zext’ instruction zero extends its operand to type ty2.
		Example:
			%X = zext i32 257 to i64              ; yields i64:257
			%Y = zext i1 true to i32              ; yields i32:1
			%Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>
	sext-to-instruction
		Syntax:
			<result> = sext <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘sext’ instruction takes a value to cast, and a type to cast it to. Both types must be of integer types, or vectors of the same number of integers. The bit size of the value must be smaller than the bit size of the destination type, ty2.
		Overview:
			The ‘sext’ sign extends value to the type ty2.
		Example:
			%X = sext i8  -1 to i16              ; yields i16   :65535
			%Y = sext i1 true to i32             ; yields i32:-1
			%Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>
	fptrunc-to-instruction
		Syntax:
			<result> = fptrunc <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘fptrunc’ instruction takes a floating-point value to cast and a floating-point type to cast it to. The size of value must be larger than the size of ty2. This implies that fptrunc cannot be used to make a no-op cast.
		Overview:
			The ‘fptrunc’ instruction truncates value to type ty2.
		Example:
			%X = fptrunc double 16777217.0 to float    ; yields float:16777216.0
			%Y = fptrunc double 1.0E+300 to half       ; yields half:+infinity
	fpext-to-instruction
		Syntax:
			<result> = fpext <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘fpext’ instruction takes a floating-point value to cast, and a floating-point type to cast it to. The source type must be smaller than the destination type.
		Overview:
			The ‘fpext’ extends a floating-point value to a larger floating-point value.
		Example:
			%X = fpext float 3.125 to double         ; yields double:3.125000e+00
			%Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000
	fptoui-to-instruction
		Syntax:
			<result> = fptoui <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘fptoui’ instruction takes a value to cast, which must be a scalar or vector floating-point value, and a type to cast it to ty2, which must be an integer type. If ty is a vector floating-point type, ty2 must be a vector integer type with the same number of elements as ty
		Overview:
			The ‘fptoui’ converts a floating-point value to its unsigned integer equivalent of type ty2.
		Example:
			%X = fptoui double 123.0 to i32      ; yields i32:123
			%Y = fptoui float 1.0E+300 to i1     ; yields undefined:1
			%Z = fptoui float 1.04E+17 to i8     ; yields undefined:1
	fptosi-to-instruction
		Syntax:
			<result> = fptosi <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘fptosi’ instruction takes a value to cast, which must be a scalar or vector floating-point value, and a type to cast it to ty2, which must be an integer type. If ty is a vector floating-point type, ty2 must be a vector integer type with the same number of elements as ty
		Overview:
			The ‘fptosi’ instruction converts floating-point value to type ty2.
		Example:
			%X = fptosi double -123.0 to i32      ; yields i32:-123
			%Y = fptosi float 1.0E-247 to i1      ; yields undefined:1
			%Z = fptosi float 1.04E+17 to i8      ; yields undefined:1
	uitofp-to-instruction
		Syntax:
			<result> = uitofp <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘uitofp’ instruction takes a value to cast, which must be a scalar or vector integer value, and a type to cast it to ty2, which must be an floating-point type. If ty is a vector integer type, ty2 must be a vector floating-point type with the same number of elements as ty
		Overview:
			The ‘uitofp’ instruction regards value as an unsigned integer and converts that value to the ty2 type.
		Example:
			%X = uitofp i32 257 to float         ; yields float:257.0
			%Y = uitofp i8 -1 to double          ; yields double:255.0
	sitofp-to-instruction
		Syntax:
			<result> = sitofp <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘sitofp’ instruction takes a value to cast, which must be a scalar or vector integer value, and a type to cast it to ty2, which must be an floating-point type. If ty is a vector integer type, ty2 must be a vector floating-point type with the same number of elements as ty
		Overview:
			The ‘sitofp’ instruction regards value as a signed integer and converts that value to the ty2 type.
		Example:
			%X = sitofp i32 257 to float         ; yields float:257.0
			%Y = sitofp i8 -1 to double          ; yields double:-1.0
	ptrtoint-to-instruction
		Syntax:
			<result> = ptrtoint <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘ptrtoint’ instruction takes a value to cast, which must be a value of type pointer or a vector of pointers, and a type to cast it to ty2, which must be an integer or a vector of integers type.
		Overview:
			The ‘ptrtoint’ instruction converts the pointer or a vector of pointers value to the integer (or vector of integers) type ty2.
		Example:
			%X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture
			%Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture
			%Z = ptrtoint <4 x i32*> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture
	inttoptr-to-instruction
		Syntax:
			<result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node]             ; yields ty2
		Arguments:
			The ‘inttoptr’ instruction takes an integer value to cast, and a type to cast it to, which must be a pointer type.
			The optional !dereferenceable metadata must reference a single metadata name <deref_bytes_node> corresponding to a metadata node with one i64 entry. See dereferenceable metadata.
			The optional !dereferenceable_or_null metadata must reference a single metadata name <deref_bytes_node> corresponding to a metadata node with one i64 entry. See dereferenceable_or_null metadata.
		Overview:
			The ‘inttoptr’ instruction converts an integer value to a pointer type, ty2.
		Example:
			%X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture
			%Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture
			%Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture
			%Z = inttoptr <4 x i32> %G to <4 x i8*>; yields truncation of vector G to four pointers
	bitcast-to-instruction
		Syntax:
			<result> = bitcast <ty> <value> to <ty2>             ; yields ty2
		Arguments:
			The ‘bitcast’ instruction takes a value to cast, which must be a non-aggregate first class value, and a type to cast it to, which must also be a non-aggregate first class type. The bit sizes of value and the destination type, ty2, must be identical. If the source type is a pointer, the destination type must also be a pointer of the same size. This instruction supports bitwise conversion of vectors to integers and to vectors of other types (as long as they have the same size).
		Overview:
			The ‘bitcast’ instruction converts value to type ty2 without changing any bits.
		Example:
			%X = bitcast i8 255 to i8              ; yields i8 :-1
			%Y = bitcast i32* %x to sint*          ; yields sint*:%x
			%Z = bitcast <2 x int> %V to i64;        ; yields i64: %V
			%Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>
	addrspacecast-to-instruction
		Syntax:
			<result> = addrspacecast <pty> <ptrval> to <pty2>       ; yields pty2
		Arguments:
			The ‘addrspacecast’ instruction takes a pointer or vector of pointer value to cast and a pointer type to cast it to, which must have a different address space.
		Overview:
			The ‘addrspacecast’ instruction converts ptrval from pty in address space n to type pty2 in address space m.
		Example:
			%X = addrspacecast i32* %x to i32 addrspace(1)*    ; yields i32 addrspace(1)*:%x
			%Y = addrspacecast i32 addrspace(1)* %y to i64 addrspace(2)*    ; yields i64 addrspace(2)*:%y
			%Z = addrspacecast <4 x i32*> %z to <4 x float addrspace(3)*>   ; yields <4 x float addrspace(3)*>:%z
other-operations
	icmp-instruction
		Syntax:
			<result> = icmp <cond> <ty> <op1>, <op2>   ; yields i1 or <N x i1>:result
		Arguments:
			The ‘icmp’ instruction takes three operands. The first operand is the condition code indicating the kind of comparison to perform. It is not a value, just a keyword. The possible condition codes are:
			eq: equal
			ne: not equal
			ugt: unsigned greater than
			uge: unsigned greater or equal
			ult: unsigned less than
			ule: unsigned less or equal
			sgt: signed greater than
			sge: signed greater or equal
			slt: signed less than
			sle: signed less or equal
			The remaining two arguments must be integer or pointer or integer vector typed. They must also be identical types.
		Overview:
			The ‘icmp’ instruction returns a boolean value or a vector of boolean values based on comparison of its two integer, integer vector, pointer, or pointer vector operands.
		Example:
			<result> = icmp eq i32 4, 5          ; yields: result=false
			<result> = icmp ne float* %X, %X     ; yields: result=false
			<result> = icmp ult i16  4, 5        ; yields: result=true
			<result> = icmp sgt i16  4, 5        ; yields: result=false
			<result> = icmp ule i16 -4, 5        ; yields: result=false
			<result> = icmp sge i16  4, 5        ; yields: result=false
	fcmp-instruction
		Syntax:
			<result> = fcmp [fast-math flags]* <cond> <ty> <op1>, <op2>     ; yields i1 or <N x i1>:result
		Arguments:
			The ‘fcmp’ instruction takes three operands. The first operand is the condition code indicating the kind of comparison to perform. It is not a value, just a keyword. The possible condition codes are:
			false: no comparison, always returns false
			oeq: ordered and equal
			ogt: ordered and greater than
			oge: ordered and greater than or equal
			olt: ordered and less than
			ole: ordered and less than or equal
			one: ordered and not equal
			ord: ordered (no nans)
			ueq: unordered or equal
			ugt: unordered or greater than
			uge: unordered or greater than or equal
			ult: unordered or less than
			ule: unordered or less than or equal
			une: unordered or not equal
			uno: unordered (either nans)
			true: no comparison, always returns true
			Ordered means that neither operand is a QNAN while unordered means that either operand may be a QNAN.
			Each of val1 and val2 arguments must be either a floating-point type or a vector of floating-point type. They must have identical types.
		Overview:
			The ‘fcmp’ instruction returns a boolean value or vector of boolean values based on comparison of its operands.
			If the operands are floating-point scalars, then the result type is a boolean (i1).
			If the operands are floating-point vectors, then the result type is a vector of boolean with the same number of elements as the operands being compared.
		Example:
			<result> = fcmp oeq float 4.0, 5.0    ; yields: result=false
			<result> = fcmp one float 4.0, 5.0    ; yields: result=true
			<result> = fcmp olt float 4.0, 5.0    ; yields: result=true
			<result> = fcmp ueq double 1.0, 2.0   ; yields: result=false
	phi-instruction
		Syntax:
			<result> = phi [fast-math-flags] <ty> [ <val0>, <label0>], ...
		Arguments:
			The type of the incoming values is specified with the first type field. After this, the ‘phi’ instruction takes a list of pairs as arguments, with one pair for each predecessor basic block of the current block. Only values of first class type may be used as the value arguments to the PHI node. Only labels may be used as the label arguments.
			There must be no non-phi instructions between the start of a basic block and the PHI instructions: i.e. PHI instructions must be first in a basic block.
			For the purposes of the SSA form, the use of each incoming value is deemed to occur on the edge from the corresponding predecessor block to the current block (but after any definition of an ‘invoke’ instruction’s return value on the same edge).
			The optional fast-math-flags marker indicates that the phi has one or more fast-math-flags. These are optimization hints to enable otherwise unsafe floating-point optimizations. Fast-math-flags are only valid for phis that return a floating-point scalar or vector type, or an array (nested to any depth) of floating-point scalar or vector types.
		Overview:
			The ‘phi’ instruction is used to implement the φ node in the SSA graph representing the function.
		Example:
			Loop:       ; Infinite loop that counts from 0 on up...
			  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
			  %nextindvar = add i32 %indvar, 1
			  br label %Loop
	select-instruction
		Syntax:
			<result> = select [fast-math flags] selty <cond>, <ty> <val1>, <ty> <val2>             ; yields ty
			
			selty is either i1 or {<N x i1>}
		Arguments:
			The ‘select’ instruction requires an ‘i1’ value or a vector of ‘i1’ values indicating the condition, and two values of the same first class type.
			The optional fast-math flags marker indicates that the select has one or more fast-math flags. These are optimization hints to enable otherwise unsafe floating-point optimizations. Fast-math flags are only valid for selects that return a floating-point scalar or vector type, or an array (nested to any depth) of floating-point scalar or vector types.
		Overview:
			The ‘select’ instruction is used to choose one value based on a condition, without IR-level branching.
		Example:
			%X = select i1 true, i8 17, i8 42          ; yields i8:17
	freeze-instruction
		Syntax:
			<result> = freeze ty <val>    ; yields ty:result
		Arguments:
			The ‘freeze’ instruction takes a single argument.
		Overview:
			The ‘freeze’ instruction is used to stop propagation of undef and poison values.
		Example:
			%w = i32 undef
			%x = freeze i32 %w
			%y = add i32 %w, %w         ; undef
			%z = add i32 %x, %x         ; even number because all uses of %x observe
			                            ; the same value
			%x2 = freeze i32 %w
			%cmp = icmp eq i32 %x, %x2  ; can be true or false
			
			; example with vectors
			%v = <2 x i32> <i32 undef, i32 poison>
			%a = extractelement <2 x i32> %v, i32 0    ; undef
			%b = extractelement <2 x i32> %v, i32 1    ; poison
			%add = add i32 %a, %a                      ; undef
			
			%v.fr = freeze <2 x i32> %v                ; element-wise freeze
			%d = extractelement <2 x i32> %v.fr, i32 0 ; not undef
			%add.f = add i32 %d, %d                    ; even number
			
			; branching on frozen value
			%poison = add nsw i1 %k, undef   ; poison
			%c = freeze i1 %poison
			br i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar
	call-instruction
		Syntax:
			<result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(<num>)]
			           <ty>|<fnty> <fnptrval>(<function args>) [fn attrs] [ operand bundles ]
		Arguments:
			This instruction requires several arguments:
			The optional tail and musttail markers indicate that the optimizers should perform tail call optimization. The tail marker is a hint that can be ignored. The musttail marker means that the call must be tail call optimized in order for the program to be correct. The musttail marker provides these guarantees:
			The call will not cause unbounded stack growth if it is part of a recursive cycle in the call graph.
			Arguments with the inalloca or preallocated attribute are forwarded in place.
			If the musttail call appears in a function with the "thunk" attribute and the caller and callee both have varargs, than any unprototyped arguments in register or memory are forwarded to the callee. Similarly, the return value of the callee is returned to the caller’s caller, even if a void return type is in use.
			Both markers imply that the callee does not access allocas from the caller. The tail marker additionally implies that the callee does not access varargs from the caller. Calls marked musttail must obey the following additional rules:
			The call must immediately precede a ret instruction, or a pointer bitcast followed by a ret instruction.
			The ret instruction must return the (possibly bitcasted) value produced by the call or void.
			The caller and callee prototypes must match. Pointer types of parameters or return types may differ in pointee type, but not in address space.
			The calling conventions of the caller and callee must match.
			All ABI-impacting function attributes, such as sret, byval, inreg, returned, and inalloca, must match.
			The callee must be varargs iff the caller is varargs. Bitcasting a non-varargs function to the appropriate varargs type is legal so long as the non-varargs prefixes obey the other rules.
			Tail call optimization for calls marked tail is guaranteed to occur if the following conditions are met:
			Caller and callee both have the calling convention fastcc or tailcc.
			The call is in tail position (ret immediately follows call and ret uses value of call or is void).
			Option -tailcallopt is enabled, llvm::GuaranteedTailCallOpt is true, or the calling convention is tailcc
			Platform-specific constraints are met.
			The optional notail marker indicates that the optimizers should not add tail or musttail markers to the call. It is used to prevent tail call optimization from being performed on the call.
			The optional fast-math flags marker indicates that the call has one or more fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations. Fast-math flags are only valid for calls that return a floating-point scalar or vector type, or an array (nested to any depth) of floating-point scalar or vector types.
			The optional “cconv” marker indicates which calling convention the call should use. If none is specified, the call defaults to using C calling conventions. The calling convention of the call must match the calling convention of the target function, or else the behavior is undefined.
			The optional Parameter Attributes list for return values. Only ‘zeroext’, ‘signext’, and ‘inreg’ attributes are valid here.
			The optional addrspace attribute can be used to indicate the address space of the called function. If it is not specified, the program address space from the datalayout string will be used.
			‘ty’: the type of the call instruction itself which is also the type of the return value. Functions that return no value are marked void.
			‘fnty’: shall be the signature of the function being called. The argument types must match the types implied by this signature. This type can be omitted if the function is not varargs.
			‘fnptrval’: An LLVM value containing a pointer to a function to be called. In most cases, this is a direct function call, but indirect call’s are just as possible, calling an arbitrary pointer to function value.
			‘function args’: argument list whose types match the function signature argument types and parameter attributes. All arguments must be of first class type. If the function signature indicates the function accepts a variable number of arguments, the extra arguments can be specified.
			The optional function attributes list.
			The optional operand bundles list.
		Overview:
			The ‘call’ instruction represents a simple function call.
		Example:
			%retval = call i32 @test(i32 %argc)
			call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32
			%X = tail call i32 @foo()                                    ; yields i32
			%Y = tail call fastcc i32 @foo()  ; yields i32
			call void %foo(i8 97 signext)
			
			%struct.A = type { i32, i8 }
			%r = call %struct.A @foo()                        ; yields { i32, i8 }
			%gr = extractvalue %struct.A %r, 0                ; yields i32
			%gr1 = extractvalue %struct.A %r, 1               ; yields i8
			%Z = call void @foo() noreturn                    ; indicates that %foo never returns normally
			%ZZ = call zeroext i32 @bar()                     ; Return value is %zero extended
			llvm treats calls to some functions with names and arguments that match the standard C99 library as being the C99 library functions, and may perform optimizations or generate code for them under that assumption. This is something we’d like to change in the future to provide better support for freestanding environments and non-C-based languages.
	va-arg-instruction
		Syntax:
			<resultval> = va_arg <va_list*> <arglist>, <argty>
		Arguments:
			This instruction takes a va_list* value and the type of the argument. It returns a value of the specified argument type and increments the va_list to point to the next argument. The actual type of va_list is target specific.
		Overview:
			The ‘va_arg’ instruction is used to access arguments passed through the “variable argument” area of a function call. It is used to implement the va_arg macro in C.
		Example:
			See the variable argument processing section.
			Note that the code generator does not yet fully support va_arg on many targets. Also, it does not currently support va_arg with aggregate types on any target.
	landingpad-instruction
		Syntax:
			<resultval> = landingpad <resultty> <clause>+
			<resultval> = landingpad <resultty> cleanup <clause>*
			
			<clause> := catch <type> <value>
			<clause> := filter <array constant type> <array constant>
		Arguments:
			The optional cleanup flag indicates that the landing pad block is a cleanup.
			A clause begins with the clause type — catch or filter — and contains the global variable representing the “type” that may be caught or filtered respectively. Unlike the catch clause, the filter clause takes an array constant as its argument. Use “[0 x i8**] undef” for a filter which cannot throw. The ‘landingpad’ instruction must contain at least one clause or the cleanup flag.
		Overview:
			The ‘landingpad’ instruction is used by LLVM’s exception handling system to specify that a basic block is a landing pad — one where the exception lands, and corresponds to the code found in the catch portion of a try/catch sequence. It defines values supplied by the personality function upon re-entry to the function. The resultval has the type resultty.
		Example:
			;; A landing pad which can catch an integer.
			%res = landingpad { i8*, i32 }
			         catch i8** @_ZTIi
			;; A landing pad that is a cleanup.
			%res = landingpad { i8*, i32 }
			         cleanup
			;; A landing pad which can catch an integer and can only throw a double.
			%res = landingpad { i8*, i32 }
			         catch i8** @_ZTIi
			         filter [1 x i8**] [@_ZTId]
	catchpad-instruction
		Syntax:
			<resultval> = catchpad within <catchswitch> [<args>*]
		Arguments:
			The catchswitch operand must always be a token produced by a catchswitch instruction in a predecessor block. This ensures that each catchpad has exactly one predecessor block, and it always terminates in a catchswitch.
			The args correspond to whatever information the personality routine requires to know if this is an appropriate handler for the exception. Control will transfer to the catchpad if this is the first appropriate handler for the exception.
			The resultval has the type token and is used to match the catchpad to corresponding catchrets and other nested EH pads.
		Overview:
			The ‘catchpad’ instruction is used by LLVM’s exception handling system to specify that a basic block begins a catch handler — one where a personality routine attempts to transfer control to catch an exception.
		Example:
			dispatch:
			  %cs = catchswitch within none [label %handler0] unwind to caller
			  ;; A catch block which can catch an integer.
			handler0:
			  %tok = catchpad within %cs [i8** @_ZTIi]
	cleanuppad-instruction
		Syntax:
			<resultval> = cleanuppad within <parent> [<args>*]
		Arguments:
			The instruction takes a list of arbitrary values which are interpreted by the personality function.
		Overview:
			The ‘cleanuppad’ instruction is used by LLVM’s exception handling system to specify that a basic block is a cleanup block — one where a personality routine attempts to transfer control to run cleanup actions. The args correspond to whatever additional information the personality function requires to execute the cleanup. The resultval has the type token and is used to match the cleanuppad to corresponding cleanuprets. The parent argument is the token of the funclet that contains the cleanuppad instruction. If the cleanuppad is not inside a funclet, this operand may be the token none.
		Example:
			%tok = cleanuppad within %cs []
